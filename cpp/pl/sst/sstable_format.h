// Copyright (c) 2024 The Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Authors: liubang (it.liubang@gmail.com)

#pragma once

#include "cpp/pl/fs/fs.h"
#include "cpp/pl/lang/assume.h"
#include "cpp/pl/status/result.h"

#include <cstdint>
#include <sstream>
#include <string>
#include <string_view>

namespace pl {

static constexpr std::size_t FOOTER_LEN = 60;
static constexpr uint32_t SST_MAGIC_NUMBER = 0x00545353;       // the hex of 'SST'
static constexpr uint32_t BLOCK_TRAILER_LEN = 5;               // compression type (1B) + crc (4B)
static constexpr uint32_t FILE_META_MAGIC_NUMBER = 0x4154454d; // the hex of 'META'
static constexpr uint32_t FILE_META_MIN_LEN = 67;

// clang-format off
#define __SST_CASE__(t, v) case t::v: return #v
// clang-format on

// clang-format off
enum class SSTType : uint8_t {
    NONE   = 0,   // invalid sst type
    MEMORY = 1,   // the sst file is generated by memory dump
    MINOR  = 2,   // the sst file is generaged by minor compaction
    MAJOR  = 3,   // the sst file is generated by major compaction
};
// clang-format on

inline const char* SSTType2String(SSTType t) {
    switch (t) {
        __SST_CASE__(SSTType, NONE);
        __SST_CASE__(SSTType, MEMORY);
        __SST_CASE__(SSTType, MINOR);
        __SST_CASE__(SSTType, MAJOR);
    }
    pl::assume_unreachable();
}

enum class SSTVersion : uint8_t {
    NONE = 0,
    V1 = 1, // current sst version is V1
};

inline const char* SSTVersion2String(SSTVersion t) {
    switch (t) {
        __SST_CASE__(SSTVersion, NONE);
        __SST_CASE__(SSTVersion, V1);
    }
    pl::assume_unreachable();
}

// clang-format off
enum class FilterPolicyType : uint8_t {
    NONE                  = 0,
    STANDARD_BLOOM_FILTER = 1,
    BLOCKED_BLOOM_FILTER  = 2,
    END                   = 2,
};
// clang-format on

inline const char* FilterPolicyType2String(FilterPolicyType t) {
    switch (t) {
        __SST_CASE__(FilterPolicyType, NONE);
        __SST_CASE__(FilterPolicyType, STANDARD_BLOOM_FILTER);
        __SST_CASE__(FilterPolicyType, BLOCKED_BLOOM_FILTER);
    }
    pl::assume_unreachable();
}

// clang-format off
enum class CompressionType : uint8_t {
    NONE   = 0,
    SNAPPY = 1,
    ZSTD   = 2,
    ISAL   = 3,
};
// clang-format on

inline const char* CompressionType2String(CompressionType t) {
    switch (t) {
        __SST_CASE__(CompressionType, NONE);
        __SST_CASE__(CompressionType, SNAPPY);
        __SST_CASE__(CompressionType, ZSTD);
        __SST_CASE__(CompressionType, ISAL);
    }
    pl::assume_unreachable();
}

#undef __SST_CASE__

// patch id 单调递增
using PatchId = uint64_t;
using SSTId = uint64_t;

/**
 * @class BlockHandle
 * @brief 主要是用来构造索引的
 */
class BlockHandle {
public:
    BlockHandle() : offset_(~static_cast<uint64_t>(0)), size_(~static_cast<uint64_t>(0)) {}

    [[nodiscard]] uint64_t offset() const { return offset_; }

    [[nodiscard]] uint64_t size() const { return size_; }

    void setOffset(uint64_t offset) { offset_ = offset; }

    void setSize(uint64_t size) { size_ = size; }

    void encodeTo(std::string* dst) const;

    [[nodiscard]] Result<Void> decodeFrom(std::string_view input);

private:
    uint64_t offset_;
    uint64_t size_;
};

/**
 * @class FileMeta
 * @brief record sst file meta data
 */
class FileMeta {
public:
    FileMeta() = default;

    void setSSTType(SSTType type) { sst_type_ = type; }

    void setSSTVersion(SSTVersion version) { sst_version_ = version; }

    void setPatchId(PatchId patch_id) { patch_id_ = patch_id; }

    void setSSTId(SSTId sst_id) { sst_id_ = sst_id; }

    void setFilterPolicyType(FilterPolicyType type) { filter_type_ = type; }

    void setCellNum(uint64_t cell_number) { cell_number_ = cell_number; }

    void setRowNum(uint64_t row_number) { row_number_ = row_number; }

    void setMinTimestamp(uint64_t min_timestamp) { min_timestamp_ = min_timestamp; }

    void setMaxTimestamp(uint64_t max_timestamp) { max_timestamp_ = max_timestamp; }

    void setMinKey(const std::string& key) { min_key_ = key; }

    void setMaxKey(const std::string& key) { max_key_ = key; }

    void setBitsPerKey(uint32_t bpk) { bits_per_key_ = bpk; }

    [[nodiscard]] SSTType sstType() const { return sst_type_; }

    [[nodiscard]] SSTVersion sstVersion() const { return sst_version_; }

    [[nodiscard]] PatchId patchId() const { return patch_id_; }

    [[nodiscard]] SSTId sstId() const { return sst_id_; }

    [[nodiscard]] FilterPolicyType filterPolicyType() const { return filter_type_; }

    [[nodiscard]] uint64_t cellNum() const { return cell_number_; }

    [[nodiscard]] uint64_t rowNum() const { return row_number_; }

    [[nodiscard]] uint64_t minTimestamp() const { return min_timestamp_; }

    [[nodiscard]] uint64_t maxTimestamp() const { return max_timestamp_; }

    [[nodiscard]] const std::string& minKey() const { return min_key_; }

    [[nodiscard]] const std::string& maxKey() const { return max_key_; }

    [[nodiscard]] uint32_t bitsPerKey() const { return bits_per_key_; }

    void encodeTo(std::string* dst) const;

    Result<Void> decodeFrom(std::string_view input);

    [[nodiscard]] std::string toString() const {
        std::stringstream ss;
        ss << "sst type: " << SSTType2String(sst_type_) << '\n';
        ss << "sst version: " << SSTVersion2String(sst_version_) << '\n';
        ss << "patch id: " << patch_id_ << '\n';
        ss << "sst id: " << sst_id_ << '\n';
        ss << "filter type: " << FilterPolicyType2String(filter_type_) << '\n';
        ss << "bits per key: " << bits_per_key_ << '\n';
        ss << "cell number: " << cell_number_ << '\n';
        ss << "row number: " << row_number_ << '\n';
        ss << "min timestamp: " << min_timestamp_ << '\n';
        ss << "max timestamp: " << max_timestamp_ << '\n';
        ss << "min key: " << min_key_ << '\n';
        ss << "max key: " << max_key_ << '\n';
        return ss.str();
    }

private:
    SSTType sst_type_{SSTType::NONE};
    SSTVersion sst_version_{SSTVersion::NONE};
    PatchId patch_id_{0};
    SSTId sst_id_{0};
    FilterPolicyType filter_type_{FilterPolicyType::NONE};
    uint32_t bits_per_key_{0};
    uint64_t cell_number_{0};
    uint64_t row_number_{0};
    uint64_t min_timestamp_{0};
    uint64_t max_timestamp_{0};
    std::string min_key_;
    std::string max_key_;
};

using FileMetaPtr = std::unique_ptr<FileMeta>;
using FileMetaRef = std::shared_ptr<FileMeta>;

class Footer {
public:
    Footer() = default;

    void setMetaindexHandle(const BlockHandle& block_handle) { filter_handle_ = block_handle; }
    void setFilterHandle(const BlockHandle& block_handle) { filter_handle_ = block_handle; }
    void setIndexHandle(const BlockHandle& block_handle) { index_handle_ = block_handle; }
    void setFileMetaHandle(const BlockHandle& block_handle) { file_meta_handle_ = block_handle; }

    [[nodiscard]] const BlockHandle& metaIndexHandle() const { return filter_handle_; }
    [[nodiscard]] const BlockHandle& filterHandle() const { return filter_handle_; }
    [[nodiscard]] const BlockHandle& indexHandle() const { return index_handle_; }
    [[nodiscard]] const BlockHandle& fileMetaHandle() const { return file_meta_handle_; }

    void encodeTo(std::string* dst) const;
    [[nodiscard]] Result<Void> decodeFrom(std::string_view input);

private:
    BlockHandle filter_handle_;
    BlockHandle index_handle_;
    BlockHandle file_meta_handle_;
};

struct BlockContents {
    std::string_view data;
    bool cachable;
    bool heap_allocated;
};

class BlockReader {
public:
    static Result<BlockContents> readBlock(const FileSystemRef& reader,
                                           const FileDescriptorRef& fd,
                                           const BlockHandle& handle);
};

} // namespace pl
